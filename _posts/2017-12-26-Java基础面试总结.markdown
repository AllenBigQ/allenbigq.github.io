---
layout: post
title:  "Java基础-面试总结"
date:   2017-12-26 22:00:00 +0000
categories: jekyll update
---


### 1.基本数据类型

#### 原始类型和包装类型
基本数据类型分为原始类型和包装类型，虽然java是面向对象编程得预言，但是为了编程的方便还是引入了原始类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型(wrapper class)，比如int的包装类型就是Integer，原始类型生成时只是一个变量，而包装类型生成的是一个实例，从Java5开始引入了自动装箱/自动拆箱机制，使得二者可以相互自动转换。


8种原始类型  | 容量 | 对应包装类型
:---:|:---:|:---:
byte(字节) | 8位 | Byte
short(短整型) | 16位 | Short
int(整型) |32位|Integer
long(长整型)|64位|Long
float(浮点型)|32位|Float
double(双精度)|64位|Double
char(字符型)|16位|Character
boolean(布尔型)|1位|Boolean

#### 装箱/拆箱
先看下面这段代码，这就是int和Integer的自动装箱
```
public class Test1 {
    public static void main(String[] args) {
        int a=1;
        Integer b =a;
        System.out.println(b);
    }
}
```
a是原始类型，b是包装类型，代码并没有报错是因为自动装箱机制，把a放进一个箱子里包裹起来，封装成了一个Integer包装类型对象，然后赋值给了b包装类型，其实这两行代码的执行效果是下面这样，Integer调用了valueOf(int i)方法。
```
Integer b=Integer.valueOf(a);//上面两行等于这一行
```
我们看一下Integer的valueOf(int i)的源码
```
public static Integer valueOf(int i) {
    assert IntegerCache.high >= 127;
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```
valueOf(int i)并不是直接new一个包装类型然后返回，而是在之前加了一个缓存。这个缓存的low-high是-128~127，也就是说当所要自动装箱的int值在-128到127之间时，会直接调用int缓存区间中的值，所有调用值的地址都是相同的，只有不在这个区间的值才会重新new一个新对象，这就是自动装箱。

跟装箱相似看一下拆箱
```
public class Test1 {
    public static void main(String[] args) {
        Integer a = new Integer(200);
        int b=a;
        System.out.println(b);
    }
}
```
这两行代码其实就是下面这两行代码
```
Integer a = new Integer(200);
        int b=a.intValue();
```
拆箱就是调用了包装类中的xxxValue()方法，比如Integer拆箱int调用了自身的intValue()方法。

这是int和Integer的装箱和拆箱，同样这八种类型都有自动装箱/拆箱的功能，只不过装箱时valueOf()中缓存有些差别。
Float、Double的valueOf()是没有缓存的，每次都是返回一个新对象，而Integer、Short是有缓存的。

#### == 、equals()判断问题

==判断的是地址是否相同，equals()判断的是存储的内容是否相同

* 都是原始类型比较时

```
public static void main(String[] args) {
        int a=1;
        int b=1;
        if (a==b){
            System.out.println("a==b");
        }else{
            System.out.println("a!=b");
        }
    }
```
因为a和b都是原始类型，原始类型所定义的变量是可以直接用\==比较判断的，输入的结果也是a==b。

* 都是包装类型比较时

我们如果没有用原始类型，而是用包装类型会怎么样呢？
```
public static void main(String[] args) {
        Integer a= new Integer(1);
        Integer b= new Integer(1);
        if (a==b){
            System.out.println("a==b");
        }else{
            System.out.println("a!=b");
        }
    }
```
输出的结果肯定是a!=b，因为此时a和b是new出来的两个不同的实例对象，虽然他们的值是相同的，但用==判断的是地址，不同的实例地址肯定也是不同的。而我们用equals()判断一下：
```
public static void main(String[] args) {
        Integer a= new Integer(1);
        Integer b= new Integer(1);
        if (a==b){
            System.out.println("a==b");
        }else if (a.equals(b)){
            System.out.println("a.equals(b)");
        }else {
            System.out.println("a!=b");
        }
    }`
```
输出的结果是a.equals(b),因为equals判断的是值(也就是其中的内容)是否相等。

下面我们看这样的代码：
```
public static void main(String[] args) {
        Integer a=1;
        Integer b=1;
        if (a==b){
            System.out.println("a==b");
        }else {
            System.out.println("a!=b");
        }
    }
```
这个代码与上面的区别是直接定义了包装类型a和b都等于1，当两个包装类型用\==比较时，先进行拆箱，变成原始类型，原始类型可以用==比较 所以输出的结果是a\==b。
```
 public static void main(String[] args) {
        Integer a=300;
        Integer b=300;
        if (a==b){
            System.out.println("a==b");
        }else {
            System.out.println("a!=b");
        }
    }
//输出结果是a!=b
```
但是当我们赋值为300后进行比较输出的结果是a!=b，这是为什么呢？
因为在前面装箱时讲过，Integer a=300 等于 Integer a = Integer.valueOf(300)，而此时就用到了缓存，缓存区间为-128~127，所以当为1时，指向的都是1的缓存地址，\==比较时就是相等，而300超出了缓存区间，所以执行了valueOf()源码中的new Integer(i)。所以Integer a=300 也就等价于 Integer a = new Integer(300)，也就是新创建了一个实例对象，所以==比较时，地址是不同的。


* 原始类型和包装类型比较时

当原始类型和包装类型比较时，包装类型会拆箱成原始类型，而刚才讲到原始类型可以直接用==判断
```
 public static void main(String[] args) {
        int a=1;
        Integer b= new Integer(1);
        if (a==b){ //包装类型拆箱后进行==比较
            System.out.println("a==b");
        }else {
            System.out.println( "a!=b");
        }
    }
```

#### 基本类型之间的转换

byte<——short、char <—— int <——long <——float <——double

容量小的向容量大的类型转换时是不需要强制转换的，比如int向double转换，就像你有10G的资料要存到20G的空间里很容易，但是要将21G的资料放进20G的空间里，可能就需要删点东西了，也就是强制转换，会丢失精度。
```
float f =2.2f;
int ff = (int)f;
//输出结果为2，没有四舍五入
```
short、char之间是不会相互转换的，byte、short、char三者在计算时首先会转换为int类型，实数常量(有小数点)默认为double类型，整数常量默认为int类型。

列出几个面试题参考一下:

**0.6332的数据类型是什么呢?**<br>
答案：double.<br>
因为实数常量默认为double类型。

**float f=3.4;是否正确?**<br>
答案：不正确。<br>
定义float正确形式是 float f=3.4f。而题中float f=3.4，3.4默认是double类型，f是float类型，此时doulbe类型赋值给float类型，大变小，需要强制转换，正确写法是float f=(float)3.4;

**下面程序中，l的最终值是多少**<br>
long l=(int)3.9;<br>
l%=2;<br>
答案：1 。3.9默认是double类型，强制转换为int类型等于3，赋值给long类型不需要强制转换，所以l=3，和2取余等于1。
*= 、/= 、+= 、-=、%=*

**short s1=1;s1=s1+1;有什么错?<br>
short s1=1;s1+=1;有什么错?**<br>
答案：s1=s1+1;这条语句是错误的，s1是short类型，short类型和int类型相加，小变大，最终为int类型，而int类型再赋值给short类型，大变小，就需要强制转换了，所以正确的写法是s1=(short)(s1+1);，而s1+=1;并没有报错，是因为加赋值是在s1基础上直接+1；而不是加1后再赋值。

**写出运行结果**
```
class Test{
    public static void main(String[] args){
        Integer a = new Integer(3);
        Integer b = 3;
        int c=3;
        System.out.println(a==b); //false
        System.out.println(a==c); //true
    }
}
```
答案：a是new出来的新对象，从堆里拿出来的，而b是从缓冲区拿出来的，因为之前讲过缓冲范围在-128~127.


### 2.String、StringBuilder、StringBuffer
**String**<br>

String被final修饰，所以是不可变类。每当我们去更改String变量的值的时候(包括重新 赋值或者使用String内部的一些方法)，其实是重新创建了一个String对象(new)来保存新的值，然后让变量指向新创建的对象，所以当我们需要频繁改变字符串的时候，使用String会带来较大的开销。

**定义String的方法有两种:**<br>
(1)String str="abc";<br>
(2)String str=new String("abc");

这两种方法其实有很大的区别，首先，第一种方式创建的String对象"abc"是存放在字符串常量池中，创建的过程是，首先在字符串常量池中查找是否存在"abc"，如果存在就将str指向它(和Integer的缓存相似)，如果不存在则在字符串常量池中创建一个"abc"，然后再将str指向它，当有另外一个String变量被赋值时，不会再重新创建，直接将字符串常量池中的地址给它。
```
String a="abc";
String b="abc";
System.out.println(a==b);  //输出true
```
上面的代码过程是：定义一个String类型的变量a，查找字符串常量池中是否存在"abc"，发现不存在则创建一个"abc"，并将a指向"abc"，再定义一个String类型的变量b，发现字符串常量池中存在"abc"，则直接将b指向"abc"的地址，所以==比较的时候输出true，因为这两个字符串变量a、b指向的"abc"是同一个，地址相同。

也就是说通过第一种方法创建的字符串在字符串常量池中，是可以共享的，同时也是不可以变的，那么什么是不可以变的呢？
```
String a="abc";
a=a+"def";
```
此时a指向"abc"，a+"def"后发现字符串常量池中没有则要重新创建一个并将a指向新创建的"abcdef"，但此时常量池中的"abc"并不会撤销。看似撤销其实是新创建，原来的还存在。

第二种创建方式其实分为两步：
```
String s="abc";
String str = new String(s);
```
第一步就是上面的第一种创建方式，第二步是在堆内存中new一个String对象，将定义的String类型的变量str指向这个对象的地址，这个对象的内容则需要到字符串常量池中找到"abc"，如果没有则要创建"abc"。所以相当于此时存在两份"abc"，一份在常量池中，一份被堆内存的String对象私有化管理，所以使用String str = new String("abc")等于创建了两个对象。

常见笔试题:<br>
**new String("abc")创建了几个对象？**<br>
答案：一个或两个。如果常量池中原来存在"abc"，那么只需要创建一个对象，如果常量池中原来没有字符串"abc"，那么就会创建两个对象。

#### StringBuffer(JDK1.0)、StringBuilder(JDK1.5)
String是不可变类，适合在需要被共享的场合中使用，而当一个字符串经常需要被修改时，同时生成很多无用的对象，由于这些无用的对象会被垃圾回收机制来回收，因此会影响程序的性能，为了解决这个问题，可以使用StringBuffer对象或者StringBuilder对象。这两个对象每次改变还是在原来的对象上发生，不会重新new出新的StringBuffer或StringBuilder对象来，所以当频繁修改字符串时使用这两个对象是很好的选择。

StringBuffer和StringBuilder的最主要区别就是线程安全方面，由于StringBuffer在大部分的方法上都添加了synchronized，所以StringBuffer是线程安全的，而StringBuilder不是线程安全的，因此当处于多线程环境下是，需要使用StringBuffer，如果我们的程序是线程安全的使用StringBuilder在性能上会更优一点。